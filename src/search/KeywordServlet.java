package search;

import classifiers.ClassifierInterface;
import contractManagement.*;
import databaseLayer.DBKeyInterface;
import log.PukkaLogger;
import net.sf.json.JSONArray;
import net.sf.json.JSONObject;
import pukkaBO.condition.*;

import pukkaBO.exceptions.BackOfficeException;
import services.Formatter;
import services.ItClarifiesService;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;

/********************************************************
 *
 *          Contract Servlet returning one contract
 *
 */

public class KeywordServlet extends ItClarifiesService {

    public static final String DataServletName = "Keywords";

    /*******************************************************************'
     *
     *          Post is not used. The keywords are generated by uploading the document
     *
     * @param req
     * @param resp
     * @throws IOException
     */


    public void doPost(HttpServletRequest req, HttpServletResponse resp)throws IOException {

        returnError("Post not supported in KeyWord", HttpServletResponse.SC_METHOD_NOT_ALLOWED, resp);
        resp.flushBuffer();

     }

    /*************************************************************************
     *
     *          Get all fragment for a project (or matching other request criteria)
     *
     *          Parameters:
     *
     *          &key=<key>      (if left empty, it will return the entire list of contracts)
     *          &project=<key>  return all the fragments for all documents ina specific project(cant be empty)
     *
     *
     *
     *          This method traverses the data structure, getting all documents fro a project, all clauses
     *          for a document and all fragments for the clauses, finally adding them all.
     *
     *
     * @throws java.io.IOException
     */


    private static final String[] fakseKeyWordList = {"förfrågningsunderlag", "interaktiva utbildningar", "Chigago",


    "utbidning","befintligt avtal", "leverantör", "exkludera", "garantera", "avtal", "avtalsperiod", "chigago",
    "dotterbolag", "offentlig upphandling", "upphandling", "tilldelningsbeslut", "organisationsnummer", "ab chigago",
    "chigago city ab", "cc resturang ab", "öppet förfarande", "tilldelningsgrund", "kontraktperson", "bill billson",
    "visma", "visma tend sign", "användarnamn och lösenord", "tidplan", "annonsering", "tidpunkt för tilldelning",
            "sista anbudsdag", "svarsformulär för anbud", "krav", "kommunikation med anbudsgivare", "förtydligande", "besvara frågor", "presentation av anbud", "anbudets omfattning", "websidor",
            "lämnande av anbud", "anbudets giltighetstid", "anbudets språk", "underteckna", "undrskrift", "villkor", "prövning och utvärdering", "ska-krav", "krav", "prövning", "utvärdering",
            "utvärderingsmodell", "särskiljning av anbud", "rättslig betydelse", "accept", "rättigheter", "kostnader", "kostnader associaerade med anbudet", "press varumärken och namn",
            "immateriella rättigheter", "pressrelease", "offentlighet och sekretess", "sekretess", "offentlighetsprincipen", "domstol", " tillsynsmyndighet", " personuppgifter",
            "personuppgiftslagen", "krav på leverantören", "anbudsgivare", "underleverantörer", "utlåtande", "uteslutande från deltagande", "konkurs", "skatter och avgifter",

    "registreringsskyldigheter",
    "utländsk anbudsgivare",
    "ekonomisk ställning",
    "kreditvärdering",
    "referensuppdrag",
    "anställda",
    "SCORM",
    "referenstagning",
    "huvudansvarig",
    "kundansvarig",
    "projektledare", "erfarenhet",
    "produktionsledare",
    "manusförfattare innehållsansvarig",
    "produktionsteam",
    "film",
    "arbetsteam",
    "pedagogik",
    "produktionskapacitet",
    "produktion ny utbildning",
    "resurs",
    "möte",
    "kvalitetssäkring",
    "samarbete",
    "miljö",
    "ISO 14001",
    "kravspecifikation",
    "pris",
    "tjänst",
    "ramavtal",
    "avropsavtal",
    "personuppgifttsbiträdesavtal",
    "behov", "volym",
    "övergripande mål",
    "vision",
    "utbildning",
    "textning", " speaker", " modul", " förkunskap", " kunskapstest",
    "ändring",
    "tillgänglighet", "PC", "Mac", "surfplatt", "smartphone",
    "explorer", "chrome", "mozilla firefox", "safari", "javascript", "ios", "android",
    "hosting", "extern hosting", "hostas", "hostas av leverantören",
    "historik", "tillgänglighet", "kapacitet",
    "vite", "åtgärd","mätning", "servicenivå", "statistik", "arvode", "timpris", "kompetens", "bedömning", "betyg",
    "##scope",
    "##ref",
    "##company", "#accountlead", "##term", "##faults",
    "##named entity", "##authorized person", "#note", "#background", "#evaluation", "##obligation",

            "#Red",
            "#Amber",
            "#Action",
            "##Warranty",
            "##Transfer",
            "##Time",
            "##Termination",
            "##Term",
            "##SLA",
            "##Schedule",
            "##Return ",
            "##Regulation",
            "##Red",
            "##Qty",
            "##Percent",
            "##Payment",
            "##NoRight ##PaymentTerms",
            "##Name",
            "##LiquidatedDamages",
            "##Language",
            "##IPR",
            "##Invoices",
            "##Delivery",
            "##DelayedPayment",
            "##Delay",
            "##Definition",
            "##Defects",
            "##Currency",
            "##Confidential",
            "##Compensation",
            "##BuyerFavourable",
            "##Acceptance",






    };






    public void doGet(HttpServletRequest req, HttpServletResponse resp)throws IOException {

        StringBuffer json = new StringBuffer();

        try{
            logRequest(req);

            if(!validateSession(req, resp))
               return;

            DBKeyInterface _project = getMandatoryKey("project", req);
            Project project = new Project(new LookupByKey(_project));

            if(!mandatoryObjectExists(project, resp))
               return;

            Formatter formatter = getFormatFromParameters(req);

            List<Keyword> keywordsForProject = project.getKeywordsForProject();
            PukkaLogger.log(PukkaLogger.Level.INFO, "Compiling " + keywordsForProject.size() + " keywords for project " + project.getName());

            JSONObject jsonObject = new JSONObject();
            JSONArray keywordList = new JSONArray();


            for (ClassifierInterface classifierInterface : defaultLanguage.getSupportedClassifiers()) {

                keywordList.put(new JSONObject()
                        .put("keyword",  "#" + classifierInterface.getClassificationName())
                        .put("document", ""));
            }


            for(Keyword keyword : keywordsForProject){

                //TODO: Make sure these are not generated as keywords.
                if(keyword.getKeyword().contains("{"))
                    continue;

                keywordList.put(new JSONObject()
                        .put("keyword",  keyword.getKeyword())
                        .put("document", keyword.getDocumentId().toString()));

            }

            jsonObject.put(DataServletName, keywordList);

            sendJSONResponse(jsonObject, formatter, resp);



        }catch(BackOfficeException e){

            PukkaLogger.log( e );
            returnError(e.narration, HttpServletResponse.SC_INTERNAL_SERVER_ERROR, resp);

        } catch ( Exception e) {

            PukkaLogger.log( e );
            returnError(e.getMessage(), HttpServletResponse.SC_INTERNAL_SERVER_ERROR, resp);
        }
    }

    public void doDelete(HttpServletRequest req, HttpServletResponse resp)throws IOException {

        returnError("Delete not supported in Keyword", HttpServletResponse.SC_METHOD_NOT_ALLOWED, resp);
        resp.flushBuffer();

    }


}
